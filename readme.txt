Sudoku Solver

My Sudoku Solver is written in Java using a strongly Object-Oriented design.  It is capable of solving all 5 sample problems provided with the assessment in a fast and relatively efficient manner.

The program is executed by running the Solver class, which has a main method that initiates the process.  The program requires a command-line argument indicating the input file to be read in.  The program then constructs a Puzzle object and calls the internal solve method on this object, which is where the primary logic for solving the puzzle resides.  Upon completion, the main method outputs the resulting puzzle state to an output file with the same name as the input but with ".sln.txt" added, ex: input "puzzle1.txt" results in output "puzzle1.txt.sln.txt".  Additionally, the result is printed to the standard output console, alongside some other concise and helpful messages about the process.

I have written comments above most methods describing their general functionality.  I considered using JavaDocs comments, but I decided that they'd be excessive for a project of this nature.  JavaDocs is useful for creating documentation for method contracts and APIs that will see a lot of use by many people, and I would favor JavaDocs on projects somewhat larger than this one.  Aside from comments of either variety, I believe that code can be significantly self-documenting by naming methods in descriptive and verbose ways that are intuitive and follow conventions, which I have also done to the best of my ability.

I have written a handful of unit tests in JUnit that test some of the internal functionality of the Puzzle class.  My current selection is not exhaustive, but rather a sample - it is possible, and perhaps prudent in a real system, to have many more.  When time and budget permit on a project, it can be a virtue to get test coverage of code as close to 100% as possible.

My algorithm for solving the puzzles involves several pieces.  First, whenever a puzzle has one or more spaces that have only one possible value it can hold, those spaces are immediately filled.  This can form a chain reaction that results in filling additional spaces.  The first 4 sample puzzles can be solved using only this method.

When a puzzle has only spaces with multiple options remaining, it must make a guess.  First, the spaces which can be guessed are prioritized from least to most possibilities.  These possibilities are then recursively explored.  Within each recursive exploration, the puzzles are once again attempted to be solved without guessing until it becomes necessary, which can lead to further recursive calls.

In order to prevent the recursive calls from exploring too deep, an overall loop around the entire solving algorithm imposes a recursive depth limit.  Only after a puzzle has been fully explored to this depth without success is the limit increased by 1 and the process attempted again.  This allows exploring breadth more than depth, though it is more accurately a hybrid of both depth-first and breadth-first methodologies.  The final sample puzzle, Puzzle #5, is deliberately designed to take a very long time without this counter-measure, but is solved efficiently with it, requiring a recursive depth of only 2.